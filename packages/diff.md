# diff 算法

更新组件主要做三件事情：更新组件 `vnode` 节点、渲染新的子树 vnode、根据新旧子树 `vnode` 执行 patch 逻辑。

首先是更新组件 `vnode` 节点，这里会有一个条件判断，判断组件实例中是否有新的组件 vnode（用 next 表示），有则更新组件 vnode，没有 next 指向之前的组件 vnode。为什么需要判断，这其实涉及一个组件更新策略的逻辑，我们稍后会讲。

接着是渲染新的子树 vnode，因为数据发生了变化，模板又和数据相关，所以渲染生成的子树 `vnode` 也会发生相应的变化。

最后就是核心的 patch 逻辑，用来找出新旧子树 `vnode` 的不同，并找到一种合适的方式更新 DOM，接下来我们就来分析这个过程。

## patch 流程

1. 如果存在新旧节点, 且新旧节点类型不同，则销毁旧节点
2. 处理文本节点
3. 处理注释节点
4. 处理静态节点
5. 处理 Fragment 元素
6. 处理普通 DOM 元素
7. 处理组件
8. 处理 TELEPORT
9. 处理 SUSPENSE

### 节点 vnode

一个元素的子节点 `vnode` 可能会有三种情况：纯文本、vnode 数组和空，排列组合对于新旧子节点来说就有九种情况

1. 旧子节点是纯文本

   1. 如果新子节点也是纯文本，那么做简单地文本替换即可
   2. 如果新子节点是空，那么删除旧子节点即可
   3. 如果新子节点是 `vnode` 数组，那么先把旧子节点的文本清空，再去旧子节点的父容器下添加多个新子节点

2. 旧子节点是空

   1. 如果新子节点是纯文本，那么在旧子节点的父容器下添加新文本节点即可
   2. 如果新子节点也是空，那么什么都不需要做
   3. 如果新子节点是 `vnode` 数组，那么直接去旧子节点的父容器下添加多个新子节点即可

3. 旧子节点是 `vnode` 数组
   1. 如果新子节点是纯文本，那么先删除旧子节点，再去旧子节点的父容器下添加新文本节点
   2. 如果新子节点是空，那么删除旧子节点即可
   3. 如果新子节点也是 `vnode` 数组，那么就需要做完整的 diff 新旧子节点了，这是最复杂的情况，内部运用了**核心 diff 算法**

### 核心 diff 算法

> 新子节点数组相对于旧子节点数组的变化，无非是通过更新、删除、添加和移动节点来完成，而核心 diff 算法，就是在已知旧子节点的 DOM 结构、vnode 和新子节点的 vnode 情况下，以较低的成本完成子节点的更新为目的，求解生成新子节点 DOM 的系列操作

1. 同步头部节点

   维护几个变量：头部的索引 i、旧子节点的尾部索引 e1 和新子节点的尾部索引 e2

   同步头部节点就是从头部开始，依次对比新节点和旧节点，如果它们相同的则执行 patch 更新节点；如果不同或者索引 i 大于索引 e1 或者 e2，则同步过程结束。

2. 同步尾部节点

   同步尾部节点就是从尾部开始，依次对比新节点和旧节点，如果相同的则执行 patch 更新节点；如果不同或者索引 i 大于索引 e1 或者 e2，则同步过程结束
